from datetime import datetime
from typing import List
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from app.entities.task import TaskEntity
from app.entities.attachment import AttachmentEntity
from app.entities.user import UserEntity
from app.exceptions.exceptions import TaskNotFound
from app.interfaces.interfaces import ITaskRepository
from app.models import User
from app.models.attachment_model import Attachment
from app.models.task_model import Task


class TaskRepository(ITaskRepository):
    def __init__(self, session: AsyncSession):
        self.session = session

    async def create_attachment(self, task_id: UUID, path: str, filename: str) -> AttachmentEntity:
        stmt = select(Attachment).where(Attachment.task_id == task_id)
        result = (await self.session.execute(stmt)).scalars().first()
        await self.session.delete(result)

        attachment = Attachment(task_id=task_id, file_path=path, filename=filename)
        self.session.add(attachment)
        await self.session.commit()
        att_ent = AttachmentEntity(
            id=attachment.id,
            task_id=attachment.task_id,
            file_path=attachment.file_path,
            filename=attachment.filename
        )
        return att_ent

    async def create(self, task: TaskEntity) -> TaskEntity:
        stmt = select(User).where(User.id.in_([u.id for u in task.responsible]))
        responsible_users = (await self.session.execute(stmt)).scalars().all()

        task_orm = Task(
            text=task.text,
            owner_id=task.owner.id,
            responsible=responsible_users,
            expired_at=task.expired_at,
            can_be_completed=task.can_be_completed,
            status=task.status,
            is_autogenerated=task.is_autogenerated,
            autogen_id=task.autogen_id,
        )
        self.session.add(task_orm)
        await self.session.commit()

        stmt = (
            select(Task)
            .options(
                selectinload(Task.owner_user),
                selectinload(Task.responsible)
            )
            .where(Task.id == task_orm.id)
        )
        result = (await self.session.execute(stmt)).scalars().first()
        task_orm = result

        task = TaskEntity(
            id=task_orm.id,
            text=task_orm.text,
            owner=UserEntity(
                id=task_orm.owner_user.id,
                name=task_orm.owner_user.name,
                surname=task_orm.owner_user.surname,
                second_name=task_orm.owner_user.second_name,
                short_name=task_orm.owner_user.short_name,
                short_name_2=task_orm.owner_user.short_name_2,
                rank_id=task_orm.owner_user.rank_id,
                post_id=task_orm.owner_user.post_id,
            ),
            responsible=[UserEntity(
                id=u.id,
                name=u.name,
                surname=u.surname,
                second_name=u.second_name,
                short_name=u.short_name,
                short_name_2=u.short_name_2,
                rank_id=u.rank_id,
                post_id=u.post_id,
            ) for u in task_orm.responsible],
            expired_at=task_orm.expired_at,
            can_be_completed=task_orm.can_be_completed,
            status=task_orm.status,
            is_autogenerated=task_orm.is_autogenerated,
            autogen_id=task_orm.autogen_id,
            created_at=task_orm.created_at,
            updated_at=task_orm.updated_at
        )
        return task


    async def update(self, task: TaskEntity) -> TaskEntity:
        pass

    async def delete(self, task: TaskEntity):
        stmt = select(Task).where(Task.id == task.id)
        result = (await self.session.execute(stmt)).scalars().first()
        result.deleted_at = task.deleted_at
        result.status = task.status
        result.deleted_by = task.deleted_by
        
        await self.session.commit()

    async def get_by_id(self, task_id: UUID) -> TaskEntity:
        stmt = (select(Task).options(
            selectinload(Task.owner_user),
            selectinload(Task.responsible),
            selectinload(Task.attachments),
        )
        .where(Task.id == task_id))
        task_orm = (await self.session.execute(stmt)).scalars().first()

        if not task_orm:
            raise TaskNotFound("Task not found")

        return TaskEntity(
            id=task_orm.id,
            text=task_orm.text,
            owner=UserEntity(
                id=task_orm.owner_user.id,
                name=task_orm.owner_user.name,
                surname=task_orm.owner_user.surname,
                second_name=task_orm.owner_user.second_name,
                short_name=task_orm.owner_user.short_name,
                short_name_2=task_orm.owner_user.short_name_2,
                rank_id=task_orm.owner_user.rank_id,
                post_id=task_orm.owner_user.post_id,
            ),
            responsible=[UserEntity(
                id=u.id,
                name=u.name,
                surname=u.surname,
                second_name=u.second_name,
                short_name=u.short_name,
                short_name_2=u.short_name_2,
                rank_id=u.rank_id,
                post_id=u.post_id,
            ) for u in task_orm.responsible],
            expired_at=task_orm.expired_at,
            can_be_completed=task_orm.can_be_completed,
            status=task_orm.status,
            is_autogenerated=task_orm.is_autogenerated,
            autogen_id=task_orm.autogen_id,
            created_at=task_orm.created_at,
            updated_at=task_orm.updated_at,
            attachments=[AttachmentEntity(
                id=a.id,
                filename=a.filename,
                file_path=a.file_path,
            ) for a in task_orm.attachments]
        )

    async def get(
        self,
        owner_id: UUID,
        responsible_id: UUID,
        is_expired: bool | None = None,
        is_completed: bool | None = None,
        is_deleted: bool | None = None,
    ) -> List[TaskEntity]:
        stmt = select(Task).where(Task.owner_id == owner_id)
